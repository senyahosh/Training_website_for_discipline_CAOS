<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CA&OS: Индивидуальное задание №4</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/lab_code_style.css">
</head>
<body id="LitBG">
	<nav class="navbar navbar-expand-lg bg-dark navbar-dark fixed-top" data-bs-theme="dark">
		<div class="container-xxl">
			<a class="navbar-brand" href="/">CA&OS</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav me-auto mb-2 mb-lg-0">
					<li class="nav-item">
						<a class="nav-link" href="/Lectures.html">Лекции</a>
					</li>
					<li class="nav-item dropdown">
						<a class="nav-link dropdown-toggle" href="" role="button" data-bs-toggle="dropdown" aria-expanded="false">
							Задания
						</a>
						<ul class="dropdown-menu">
							<li><a class="dropdown-item" href="/Labs.html">Лабораторные работы</a></li>
							<li><a class="dropdown-item" href="/Tests.html">Тестирование</a></li>
							<li><a class="dropdown-item" href="/Indivs.html">Индивидуальные задания</a></li>
						</ul>
					</li>
					<li class="nav-item dropdown">
						<div class="btn-group">
							<a href="/Other.html" class="nav-link"> Прочее </a>
							<a class="nav-link dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
								<span class="visually-hidden">Toggle Dropdown</span>
							</a>
							<ul class="dropdown-menu">
								<li><a class="dropdown-item" href="/Other.html#distributions">Дистрибутивы</a></li>
								<li><a class="dropdown-item" href="/Other.html#help">Справочная информация</a></li>
							</ul>
						</div>
					</li>
					<li class="nav-item">
						<a class="nav-link" href = "#contact">Контакты</a>
					</li>
				</ul>
				<form class="d-flex me-3" role="search">
					<input class="form-control me-1" type="search" placeholder="Поиск" aria-label="Search">
					<button class="btn btn-outline-light" type="submit">Поиск</button>
				</form>
				<ul class="navbar-nav">
					<li class="nav-item">
						<a class="nav-link" href="/Authorization.html">Авторизация</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<section>
		<div id="LiteraturePage" class="container-xxl">
			<div class="lec-container">	
				<h1 align="center"> Индивидуальное задание №4. <br> Операционные системы </h1>
				<h2 align="center"> Задания для решения дома </h2>
				<hr style="border: 1px solid rgba(0, 0, 0, 0.6); margin: 30px 0px 20px;">
				<div class="container-xxl">

					<p>
						<u style="color: red;">
							Указание: Необходимо реализовать первое задание в каждом варианте  в последовательном и многопоточном варианте, результаты сравнить между собой.  
						</u>
					</p>

					<h4 class="clang-h4"> Вариант 1 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Написать программу, которая получает список файлов и для каждого файла вычисляет количество повторений символа.  Каждый файл должен обрабатываться в отдельном потоке. Основной поток должен по окончании обработки выводить результаты.
						</li>
						<li>
							<p>Пусть есть два циклических процесса, каждый из которых имеет доступ к общему файлу F. Оба процесса выполняют два системных обращения к файлу: Read и Write. Пусть каждый из процессов имеет вид</p>
							<p align="center">
								begin L:&nbsp;&nbsp; …&nbsp;&nbsp;Read;&nbsp;&nbsp; …&nbsp;&nbsp; Write;&nbsp;&nbsp;…&nbsp;&nbsp; go to L&nbsp;&nbsp; end;
							</p>
							<p style="margin-bottom: 0em;">Любое число операций Read может выполняться одновременно, но каждая операция Write – есть критическая секция по отношению как к операции Read, так и другой операции Write. Используя известные вам программные методы синхронизации, напишите программы для каждого из процессов.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 2 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Дана матрица целых чисел, представляющая некоторое изображение. Получить по ней другую матрицу тех же размеров, представляющую размытый вариант изображения. Каждый элемент новой матрицы должен быть получен как среднее арифметическое значений элемента старой с теми же координатами и соседних с ним элементов (координаты которых отличаются от текущего не более, чем на 1). Разделить работу между *n* потоками. Каждый поток должен вычислить значения в заданной ему полосе матрицы.
						</li>
						<li>
							<p>Пусть есть два циклических процесса, каждый из которых имеет доступ к общему файлу F. Оба процесса выполняют два системных обращения к файлу: Read и Write. Пусть каждый из процессов имеет вид</p>
							<p align="center">
								begin L:&nbsp;&nbsp; …&nbsp;&nbsp;Read;&nbsp;&nbsp; …&nbsp;&nbsp; Write;&nbsp;&nbsp;…&nbsp;&nbsp; go to L&nbsp;&nbsp; end;
							</p>
							<p style="margin-bottom: 0em;">Любое число операций Read может выполняться одновременно, но каждая операция Write – есть критическая секция по отношению как к операции Read, так и другой операции Write. Используя операции Дейкстры и соответствующие семафоры, расставьте их относительно операций Read и Write в каждом из процессов, чтобы правильно удовлетворить указанным ограничениям. Напишите программы для каждого из процессов.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 3 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Задача "эволюция". Дано двумерное поле клеток, каждая из которых либо содержит организм (1), либо пуста (0). Каждая клетка проверяет состояние своих соседей (их 8) и изменяет своё по правилам:
							<ul>
								<li>
									Живая клетка, вокруг которой &lt; 2 живых клеток, умирает от одиночества.
								</li>
								<li>
									Живая клетка, вокруг которой есть 2 или 3 живых клеток, выживает.
								</li>
								<li>
									Живая клетка, вокруг которой &gt; 3 живых клеток, умирает от перенаселения.
								</li>
								<li>
									Пустая клетка, рядом с которой равно 3 живых соседа, оживает.
								</li>
							</ul>
							Реализовать один шаг моделирования при помощи *n* потоков, записав результат моделирования в другую матрицу тех же размеров.. Каждый поток должен вычислить значения в заданной ему полосе матрицы.
						</li>
						<li>
							Рассмотрите алгоритм планирования распределения времени центрального процессора – простой круговорот (циклическое квантование). Сделайте его модельную реализацию при условии, что заранее известно время выполнения каждого процесса. При получении очередного кванта процессом, время его выполнения уменьшается на величину кванта. При завершении некоторого процесса, надо пересчитывать величину кванта. В качестве выводимой информации надо получать текущее состояние очереди процессов и величину кванта.
						</li>
					</ol>	

					<h4 class="clang-h4"> Вариант 4 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Заданы две матрицы вещественных чисел размеров <i>NxN</i>. Выполнить операцию умножения двух матриц в <i>k</i> потоках. Каждый поток должен обрабатывать заданный набор строк первой матрицы и часть второй.
						</li>
						<li>
							В системах с виртуальной страничной организацией памяти те страницы, содержимое которых не менялось, пока они находились в оперативной памяти, не переписываются обратно на диск, когда их вытесняют из оперативной памяти. Напишите программу, реализующую модель принятия таких решений.
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 5 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Даны два массива вещественных чисел одинаковой длины. Вычислить скалярное произведение векторов, представленных этими массивами, разделив работу между <i>n</i> потоками. Каждый поток должен выполнить вычисления в заданном ему фрагменте массивов.
						</li>
						<li>
							Напишите процедуры для запроса и освобождения памяти, использующие стратегию размещения «первый подходящий», и структуру данных для хранения информации о доступных пространствах. На вход процедуре запроса должен поступать размер запрашиваемого блока (в байтах). Процедура должна вернуть адрес блока, если запрос может быть удовлетворен. В противном случае – вернуть 0. Процедура освобождения памяти должна получать в качестве входного параметра адрес adr. Результатом ее выполнения должно быть добавление блока, начиная с адреса adr, к доступному пространству.
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 6 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							В двумерном массиве заданы значения вещественной функции от двух переменных в некоторой решётке. Выполнить поиск всех локальных максимумов заданной функции (локальным максимумом считать значение, большее своих восьми соседей. Разделить вычисления между <i>n</i> потоками. Каждый поток должен вычислить значения в заданной ему полосе массива.
						</li>
						<li>
							<p>Напишите Программу, сравнивающую различные стратегии планирования работы с диском. Для этого смоделируйте обращения нескольких процессов к различным участкам диска. В каждом таком обращении должны фигурировать номер цилиндра, номера первого и последнего сектора запроса и код операции. Для каждого обращения существенным является время постановки задания в очередь. В качестве конфигурации дискового устройства надо задать время перемещения каретки к соседнему цилиндру, время вращения диска на 1 сектор, и время выполнения операции над одним сектором.</p>
							<p>Используя Программу, сравните стратегию FCFS и SSTF. Выдайте для одинаковых входных данных (одной и той же очереди запросов к диску) значения пропускной способности, среднее время ответа и дисперсию времен ответа для каждой из указанных выше стратегий. Символически изобразите поведение каретки для каждой из стратегий. Сделайте выводы относительно применимости стратегий в зависимости от различных условий - размер очереди, интерактивность операционной системы, соотношение времени планирования и времени обслуживания запроса.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 7 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Дана матрица, представляющая некоторое  изображение (со значениями 1 — "есть цвет" и 0 — "нет"). Получить по ней другую матрицу тех же размеров, представляющую сглаженное изображение (без "пиков" и "зазубрин"). В новом изображении необходимо затемнить все светлые пиксели, у которых как минимум <i>d</i> (&lt;9) соседей не освещены, и осветлить тёмные, у которых как минимум <i>d</i> соседей освещены. Разделить работу между <i>n</i> потоками. Каждый поток должен вычислить значения в заданной ему полосе матрицы.
						</li>
						<li>
							<p>Напишите Программу, сравнивающую различные стратегии планирования работы с диском. Для этого смоделируйте обращения нескольких процессов к различным участкам диска. В каждом таком обращении должны фигурировать номер цилиндра, номера первого и последнего сектора запроса и код операции. Для каждого обращения существенным является время постановки задания в очередь. В качестве конфигурации дискового устройства надо задать время перемещения каретки к соседнему цилиндру, время вращения диска на 1 сектор, и время выполнения операции над одним сектором.</p>
							<p>Используя Программу, сравните стратегию FCFS и SCAN. Выдайте для одинаковых входных данных (одной и той же очереди запросов к диску) значения пропускной способности, среднее время ответа и дисперсию времен ответа для каждой из указанных выше стратегий. Символически изобразите поведение каретки для каждой из стратегий. Сделайте выводы относительно применимости стратегий в зависимости от различных условий - размер очереди, интерактивность операционной системы, соотношение времени планирования и времени обслуживания запроса.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 8 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Для заданной квадратной целочисленной матрицы проверить свойство диагональной постоянности: главная диагональ и все диагонали, параллельные главной, должны состоять из одинаковых (в пределах этой диагонали) значений. Разделить вычисления между <i>n</i> потоками. Каждый поток должен вычислить значения в заданном ему диапазоне диагоналей. Алгоритм можно оптимизировать, прекращая вычисления, когда какой-либо из потоков обнаруживает нарушение условия.
						</li>
						<li>
							<p>Напишите Программу, сравнивающую различные стратегии планирования работы с диском. Для этого смоделируйте обращения нескольких процессов к различным участкам диска. В каждом таком обращении должны фигурировать номер цилиндра, номера первого и последнего сектора запроса и код операции. Для каждого обращения существенным является время постановки задания в очередь. В качестве конфигурации дискового устройства надо задать время перемещения каретки к соседнему цилиндру, время вращения диска на 1 сектор, и время выполнения операции над одним сектором.</p>
							<p>Используя Программу, сравните стратегию SSTF и C-SCAN. Выдайте для одинаковых входных данных (одной и той же очереди запросов к диску) значения пропускной способности, среднее время ответа и дисперсию времен ответа для каждой из указанных выше стратегий. Символически изобразите поведение каретки для каждой из стратегий. Сделайте выводы относительно применимости стратегий в зависимости от различных условий - размер очереди, интерактивность операционной системы, соотношение времени планирования и времени обслуживания запроса.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 9 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Для заданной квадратной целочисленной матрицы проверить, является ли она псевдо-магическим квадратом: должны совпадать суммы чисел в каждой её строке, каждом столбце, а также на главной и на побочной диагонали (у магического квадрата должно ещё выполняться условие, что все числа различны).   Разделить вычисления между <i>n</i> потоками. Каждый поток должен вычислить значения в заданной ему горизонтальной и вертикальной полосах матрицы. Также первый поток может вычислять сумму элементов на главной диагонали, а последний - на побочной. Алгоритм можно оптимизировать, прекращая вычисления, когда какой-либо из потоков обнаруживает нарушение условия.
						</li>
						<li>
							<p>Напишите Программу, сравнивающую различные стратегии планирования работы с диском. Для этого смоделируйте обращения нескольких процессов к различным участкам диска. В каждом таком обращении должны фигурировать номер цилиндра, номера первого и последнего сектора запроса и код операции. Для каждого обращения существенным является время постановки задания в очередь. В качестве конфигурации дискового устройства надо задать время перемещения каретки к соседнему цилиндру, время вращения диска на 1 сектор, и время выполнения операции над одним сектором.</p>
							<p>Используя Программу, сравните стратегию C-SCAN и N-Step SCAN. Выдайте для одинаковых входных данных (одной и той же очереди запросов к диску) значения пропускной способности, среднее время ответа и дисперсию времен ответа для каждой из указанных выше стратегий. Символически изобразите поведение каретки для каждой из стратегий. Сделайте выводы относительно применимости стратегий в зависимости от различных условий - размер очереди, интерактивность операционной системы, соотношение времени планирования и времени обслуживания запроса.</p>
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 10 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Выполнить циклический сдвиг на один элемент вправо/вниз всех строк и столбцов заданной матрицы. Каждый из потоков должен обрабатывать свой диапазон столбцов. Необходимо выполнить следующие действия в каждом потоке:
							<ul>
								<li>выполнить циклический сдвиг внутри каждого столбца;</li>
								<li>сдвинуть вправо все столбцы, перемещаемые в пределах того же диапазона;</li>
								<li>сдвинуть вправо (в начало матрицы) все граничные столбцы — по согласованию с соседними потоками.</li>
							</ul>
						</li>
						<li>
							Задача о спящем парикмахере (Дейкстра, 1968). Парикмахерская состоит из комнаты ожидания W и комнаты B, в которой стоят парикмахерские кресла. Через раздвижные двери D  можно попасть из комнаты B в комнату W, а из комнаты W на улицу. Если парикмахер заходит в комнату W и никого там не обнаруживает, то он идет спать. Если клиент входит в парикмахерскую и находит парикмахера спящим, то он должен его разбудить. В комнате ожидания имеется конечное число стульев n. Запрограммируйте парикмахера и клиентов как процессы. Для синхронизации их работы воспользуйтесь одним из аппаратных механизмов.
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 11 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Из заданной квадратной целочисленной матрицы получить матрицу, в которой в каждой строке элементы идут в обратном порядке в сравнении с исходной матрицей. Разделить вычисления между <i>n</i> потоками. Каждый поток должен вычислить значения в заданном ему диапазоне строк. 
						</li>
						<li>
							Промоделируйте работу операционной системы по планированию распределения времени ЦП "сначала самые короткие задания". Пусть через время <i>T</i> в системе случайным образом генерируется появление задания с указанием ожидаемого времени выполнения <i>t</i> и добавляется в очередь заданий выполнения в ту позицию, которая соответствует <i>t</i>. Задания в очереди упорядочены по возрастанию времени их выполнения. Имитируйте выделение ЦП самому короткому заданию, по истечении времени выполнения задания "переключайте" процессор на следующее задание. Меняя <i>T</i> и диапазон для генерируемых <i>t</i>, проанализируйте при каких значениях <i>T</i> и  диапазон для генерируемых <i>t</i> у "длинных" заданий появляется шанс быть выполненными. 
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 12 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Дана матрица размера <i>NxM</i>. Получить по ней другую матрицу тех же размеров, представляющую вместо каждого элемента исходной матрицы среднее арифметическое соседних с ним элементов. Для первых и последних столбцов и строк число соседей будет 3 или 5. Для остальных элементов матрицы вычисление выполнять по всем 8-ми соседям. Разделить работу между <i>n</i> потоками. Каждый поток должен вычислить значения в заданной ему части матрицы.
						</li>
						<li>
							Промоделируйте работу операционной системы по планированию распределения времени ЦП "сначала с наименьшим оставшимся временем выполнения". Пусть через время <i>T</i> в системе случайным образом генерируется появление задания с указанием ожидаемого времени выполнения <i>t</i> и добавляется в очередь заданий выполнения в ту позицию, которая соответствует <i>t</i>.  Пусть величина времени ЦП, отведенного каждому процессу - <i>q</i>.  Имитируйте выделение ЦП заданию "с наименьшим оставшимся временем выполнения". Во время выполнения сгенерируйте случайным образом логическое значение, 0-процесс не прерван на операции ввода вывода, 1 - процесс заблокирован операцией ввода-вывода сигнал. Переведите его в очередь заблокированных процессов, пересчитав оставшееся время выполнения. Если блокировка произошла, "переключайте" процессор на следующее задание. Если блокировки не было, то по истечении кванта <i>q</i>, найдите среди готовых к выполнению процессов тот,  оставшимся временем выполнения которого минимально. Периодически "будите" заблокированные на операции ввода-вывода процессы. Меняя  <i>T</i>, <i>q</i>, интервал генерации операций ввода-вывода и диапазон для генерируемых <i>t</i>, проанализируйте продвижение процессов. 
						</li>
					</ol>

					<h4 class="clang-h4"> Вариант 13 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Заданы две матрицы вещественных чисел размеров <i>NxM</i> и <i>MxK</i>. Выполнить операцию умножения двух матриц в нескольких потоках. Каждый поток должен обрабатывать заданный набор строк первой матрицы и часть второй.
						</li>
						<li>
							Рассмотрите алгоритм планирования процессов по приоритетам с вытеснениями,  когда приоритет каждого процесса меняется во времени. Скорость изменения приоритета пропорциональна константе <i>a</i>, когда процесс ждет, и константе <i>b</i>, когда он выполняется. Пусть через время <i>T</i> в системе случайным образом генерируется появление задания с указанием ожидаемого времени выполнения <i>t</i> и приоритетом <i>P</i> и добавляется в очередь заданий. Если приоритет нового процесса больше, чем приоритет выполняемого, то ЦП сразу выделяется новому процессу. Если имеется несколько процессов с наивысшим приоритетом, то все они обслуживаются в режиме разделения времени с очень малой величиной кванта <i>q</i>. Через интервал времени <i>T</i> приоритеты всех процессов пересчитываются. Исследуйте поведение алгоритма в полном диапазоне изменения величин <i>a</i>, <i>b</i>, диапазона приоритетов и <i>T</i>.
						</li>
					</ol>
					
					<h4 class="clang-h4"> Вариант 14 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Задан массив A вещественных значений размера <i>n</i>, а также вещественный отрезок [<i>a</i>, <i>b</i>] и натуральное число <i>m</i>. Определить, сколько элементов массива <i>A</i> принадлежат полуинтервалам [<i>a</i>,&nbsp; <i>a</i>&nbsp;+&nbsp; <i>h</i>), [<i>a</i> &nbsp;+&nbsp; <i>h</i>,&nbsp; <i>a</i> &nbsp;+ 2&nbsp; <i>h</i>), ... [<i>a</i> &nbsp;+ (<i>m</i>&nbsp; - 1)&nbsp; <i>h</i>,&nbsp; <i>b</i>), где&nbsp; <i>h</i> &nbsp;= (<i>b</i> &nbsp;-&nbsp; <i>a</i>) /&nbsp; <i>m</i>. Реализовать вычисление с помощью нескольких потоков.  Счётчик для каждого полуинтервала защитить отдельным мьютексом.
						</li>
						<li>
							Напишите процедуры для запроса и освобождения памяти, использующие стратегию размещения «наилучший» (best-fit), и структуру данных  для хранения информации о  доступных пространствах. На вход процедуре запроса должен поступать размер запрашиваемого блока (в байтах). Процедура должна вернуть адрес блока, если запрос может быть удовлетворен. В противном случае – вернуть 0. Процедура освобождения памяти должна получать в качестве входного параметра адрес adr. Результатом ее выполнения должно быть добавление блока, начиная с адреса adr, к доступному пространству.
						</li>
					</ol>
					
					<h4 class="clang-h4"> Вариант 15 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							Задано вещественное число <i>a</i> и натуральное число <i>m</i>. Массив <i>A</i> размера <i>n</i> заполняется случайными целыми числами в полуинтервале [0, <i>a</i>). Затем необходимо скопировать все нечётные значения из массива A в список <i>L</i><sub>1</sub>, а все чётные — в список <i>L</i><sub>2</sub>. Задачу по распределению чисел по спискам необходимо выполнить, разделив работу между <i>p</i> потоками. По окончании вывести содержимое обоих списков вместе с их размерами.
						</li>
						<li>
							Напишите процедуры для запроса и освобождения памяти, использующие стратегию размещения «наименее подходящий» ((worst-fit), и структуру данных  для хранения информации о  доступных пространствах. На вход процедуре запроса должен поступать размер запрашиваемого блока (в байтах). Процедура должна вернуть адрес блока, если запрос может быть удовлетворен. В противном случае – вернуть 0. Процедура освобождения памяти должна получать в качестве входного параметра адрес adr. Результатом ее выполнения должно быть добавление блока, начиная с адреса adr, к доступному пространству.
						</li>
					</ol>
					
					<h4 class="clang-h4"> Вариант 16 </h4>
					<ol class="clang-task" style="padding-left: 1.5em;">
						<li>
							В двумерном массиве заданы значения вещественной функции от двух переменных в некоторой решётке. Выполнить поиск всех максимумов заданной функции по строкам и по столбцам. Разделить вычисления между <i>n</i> потоками. Каждый поток должен вычислить значения в заданной ему части массива.
						</li>
						<li>
							Промоделируйте работу системы приоритетного планирования CTSS (см. стр. 191 в книге <a href="https://drive.google.com/file/d/1SjoqCydcRNf1_G_ZEQvH8ZsaqOE0oRXs/view">Таненбаум Э., Бос Х. Современные операционные системы</a>).  Пусть через время <i>T</i> в системе случайным образом генерируется появление задания с указанием ожидаемого времени выполнения <i>t</i> и приоритетом <i>P</i> и добавляется в очередь  заданий соответствующего класса приоритетов.  Исследуете продвижение заданий по очередям класса приоритетов. 
						</li>
					</ol>

					<form id="uploadForm" enctype="multipart/form-data">
						<input type="file" name="file" id="fileInput" class="fileloader">
						<button type="submit" class="btn btn-primary" id="load"> Сдать задание </button>
					</form>

					<div id="container">
						<div id="reveal-modal">
							<div id=text>
								<pre></pre>
							</div>
							<button class="btn" id="close"> Закрыть </button>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>

	<footer class="footer-dark bg-dark">
		<p><a name="contact"></a></p>
		<div class="container-xxl">
			<div class="row align-items-center">
				<div class="col-5">
					<ul class="list-group list-group-flush">
						<li class="list-group-item bg-dark text-light"> Руководитель курса: доц. к. ф.-м. н. Андреева Евгения Михайловна <br> Кафедра информатики и вычислительного эксперимента </li>
						<li class="list-group-item bg-dark text-light"> Адрес: г. Ростов-на-Дону, ул. Мильчакова 8А, ауд. 203</li>
						<li class="list-group-item bg-dark text-light">
							Телефон:
							<ol class="list-group list-group-numbered">
								<li class="bg-dark text-light"> +7(863) 218-40-00 доб. 11062 </li>
								<li class="bg-dark text-light"> +7(863) 468-08-90 доб. 11062 </li>
							</ol>
						</li>
						<li class="list-group-item bg-dark text-light"> Корпоративная почта: 
							<a href="#contact" class="link-primary"> andreeva@sfedu.ru </a> 
						</li>
						<li class="list-group-item bg-dark text-light"> Персональная страница: <a href="https://sfedu.ru/person/andreeva" class="link-primary"> https://sfedu.ru/person/andreeva </a></li>
					</ul>
				</div>
				<div class="col-2"> </div>
				<div class="col-5">
    				<form>
						<div id="InputForm">
							<input required type="email" class="form-control" placeholder="example@sfedu.ru">
						</div>
						<div id="InputForm">
							<textarea required type="text" class="form-control" placeholder="Введите сообщение" rows = "4"></textarea>
						</div>
						<button class="btn btn-block btn-md btn-outline-light" type="button"> Отправить </button>
					</form>
    			</div>
			</div>
		</div>
		<hr id="mainhr">
		<div class="text-center bg-dark" style="color: rgba(255, 255, 255, 0.5);"> &copy 2023-2024 </div>
	</footer>

	<script>

		function runCommands(fileName) {

			const filename = fileName;
			const commands = [
				'docker build --build-arg C_FILE=' + filename + ' -t c-compiler C:\\Users\\111\\MySite\\uploads\\.',
				'docker run -v C:\\Users\\111\\MySite\\uploads\\' + filename + ':/code cppcheck-image cppcheck --quiet --enable=all --std=c11 --language=c /code'
			];

			const testFiles = [];

			const dataToSend = {
				commands: commands,
				testFiles: testFiles
			};

			const socket = new WebSocket('ws://localhost:8080');

			socket.onopen = () => {
				socket.send(JSON.stringify(dataToSend));
			};

			socket.onmessage = (event) => {
				showOutput(event.data);
			};

			socket.onerror = (error) => {
				console.error('WebSocket error:', error);
			};
		}

		// Всплывающее окно с ошибками	
		const modal = document.querySelector('#container');
		const close = document.querySelector('#close');

		function showOutput(output) {
        	var text = document.getElementById("text");
			var newNode = document.createElement("pre");
			var oldNode = text.firstElementChild;
			newNode.textContent = output;
			text.replaceChild(newNode, oldNode);

			modal.style.display = 'block';
			modal.style.visibility = 'visible';
        }

        close.onclick = function () {
			modal.style.display = 'none';
			modal.style.top = '50%';
		};

		window.addEventListener('scroll', () => {
			modal.style.top = `${window.innerHeight / 4}px`;
		});

		document.addEventListener('keydown', function(e) {
			if(e.keyCode == 27){
				modal.style.display = 'none';
				modal.style.top = '50%';
			}
		});

		// Загрузка файла
        const uploadForm = document.getElementById('uploadForm');
    	uploadForm.addEventListener('submit', async (e) => {
    		e.preventDefault();

    		const formData = new FormData();
    		const fileInput = document.getElementById('fileInput');

    		if (fileInput.files && fileInput.files.length == 1) {
    			formData.append('file', fileInput.files[0]);
    			var filename = fileInput.files[0].name;

    			try {
	    			const response = await fetch('http://localhost:8000/upload', {
	    				method: 'POST',
	    				body: formData
	    			});

	    			if (response.ok) {

	    				console.log('File uploaded successfully!');
	    				alert('Файл успешно загружен!\nЗакройте это сообщение, чтобы посмотреть отчёт о проверке.\n\nВнимание! Это может занять некоторое время.');

	    				runCommands(filename);
	    			
	    			} else {
	    				console.error('Failed to upload file');
	    				alert('Ошибка при загрузке файла.')	    			
	    			}

	    			uploadForm.reset();

	    		} catch (error) {
	    			console.error(error);
	    		}
    		}
    		else {
    			alert('Файл не прикреплен.');   		
    		}
    	});

	</script>

	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
</body>
</html>